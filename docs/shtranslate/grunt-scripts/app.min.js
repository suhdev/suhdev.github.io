/**
 * @ngdoc overview 
 * @name ngSuh
 * @module ngSuh
 * @description 
 * #ngSuh 
 * Provides a set of general tools [Suhail](http://www.suhailabood.me)
 */
angular.module('ngSuh',[]);   
angular.module('ngSuh')
	.directive('suhLang', ['I18NLang','$compile','$parse',function (lang,$CC,$PP) {
		return {
			restrict: 'A',
			link: function postLink($S, $E, $A) {
				var matches = [],
					locale = $A['suhLangLocale'],
					key = $A['suhLang'],
					replacements,
					tempRepl,
					trans = lang.get(key);
				$S.translate = $S.translate || {};

				Object.defineProperty($S.translate,key.replace(/\./g,'_'),{
					get:function(){
						console.log(trans.value);
						return trans.value;
					}
				});
				// for(var key in $A){
				// 	matches = key.match(/suhLangAttrKey([A-Z].+)/);
				// 	if (matches && matches.length > 1){
				// 		replacements = $A['langAttr'+matches[1]+'Replacements']; 
				// 		if (replacements){
				// 			getter = $PP(replacements);
				// 			tempRepl = getter($S);
				// 			if (tempRepl){

				// 			}
				// 		}
				// 		if (locale){
				// 			$E.attr(matches[1].toLowerCase(),lang.get($A[key],replacements).value);
				// 		}
				// 	}
				// 	matches = key.match()
				// }
			}
		};
	}])
/**
 * @ngdoc service
 * @name ngSuh.I18NLangProvider 
 * @description 
 * Provides a simple interface for translation.
 * 
 */
angular.module('ngSuh')
	.provider('I18NLang', [function () {
		var repositories = {},
			locale = 'en-US',
			fallbackLocale = 'en-US';

		function checkLocale(loc){
			if (!angular.isString(loc)){
				throw new Error("Locale should be a string")
			}else if (!(/[a-z]{2}-[A-Z]{2}/.test(loc))){
				throw new Error("Locale should be an ISO-compliant string i.e. en-GB");
			}
		}

		function checkRepositoryUrl(url){
			if (!angular.isString(url)){
				throw new Error("The provided URL isn't a string");
			}
		}

		this.addRepository = function(loc,url){
			if (angular.isObject(loc)){
				repositories = angular.extend({},repositories, loc);
			}else {
				checkLocale(loc);
				checkRepositoryUrl(url);
				repositories[loc] = url;
			}
		};

		this.setLocale = function(loc){
			checkLocale(loc);
			locale = loc;
		};

		this.setFallbackLocale = function(loc){
			checkLocale(loc);
			fallbackLocale = loc;
		};
	
		this.$get = ['$http','$q',function($H,$Q) {
			var db = {},
				cache = {},
				def = $Q.defer(),
				fallbackLoaded = false,
				mainLoaded = false;

			function getAt(obj,keyPath){
				var path = keyPath.split('.'),
					o = obj,
					k = null;
				console.log(path);
				while((o && (k = path.shift()))){
					o = o[k]; 
				}
				return o;
			}

			function hashCode(code){
			  var hash = 0, i, chr, len;
			  if (code.length == 0) return hash;
			  for (i = 0, len = code.length; i < len; i++) {
			    chr   = code.charCodeAt(i);
			    hash  = ((hash << 5) - hash) + chr;
			    hash |= 0; // Convert to 32bit integer
			  }
			  return hash;
			}

			function loadLocale(loc,url){
				return $H.get(url)
					.success(function(e){
						db[loc] = e;
					});
			}
			function main(){
				var url = repositories[locale];
				if (url){
					loadLocale(locale,url)
					.then(function(){
						mainLoaded = true;
						def.resolve();
					});
				}
				url = repositories[fallbackLocale];
				if (url && (url != repositories[locale])){
					loadLocale(fallbackLocale,url)
						.then(function(){
							fallbackLoaded = true;
						});
				}
			}

			var o = {
				ready:function(){
					return def.promise;
				},
				isLocaleLoaded:function(){
					return mainLoaded;
				},
				isFallbackLocaleLoaded:function(){
					return fallbackLoaded;
				},
				setLocale:function(loc){
					locale = loc;
					loadLocale(loc,repositories[loc]);
				},
				format:function(loc,key,replacements){
					var hashKey = (replacements)?(loc+key+JSON.stringify(replacements)):(loc+key),
						code = hashCode(hashKey),
						currentDb = loc?db[loc]:(db[locale]?db[locale]:(db[fallbackLocale]?db[fallbackLocale]:null)),
						item = getAt(currentDb,key);

					console.log(db);
					if (cache[""+code]){
						console.log(cache);
						return cache[""+code];
					}
					if (item){
						if (!angular.isDefined(replacements)){
							cache[""+code] = item;
							return item;
						}
						if (angular.isArray(replacements)){
							if (cache[""+code]){
								return cache[""+code];
							}
							for(var i=0,l=replacements.length;i<l;i++){
								item = item.replace("?",replacements[i]);
							}
						}else if (angular.isObject(replacements)){
							for(var key in replacements){
								item = item.replace(new RegExp(key,"ig"),getAt(replacements,key));
							}
						}
						cache[""+code] = item;
					}
					return item;
				},
				get:function(){
					var loc,key,replacements;
					switch(arguments.length){
						case 0:
							throw new Error("No parameters passed to translate method");
							break;
						case 1:
							if (angular.isObject(arguments[0])){
								loc = arguments[0].locale;
								key = arguments[0].key,
								replacements = arguments[0].replacements || {};
							}else{
								key = arguments[0];
							}
							break;
						case 2:
							key = arguments[0];
							replacements = arguments[1];
							break;
						case 3:
							loc = arguments[0];
							key = arguments[1];
							replacements = arguments[2];
							break;
					}
					var t = {
						translate:function(){
							return o.format(loc||locale,key,replacements);
						}
					};

					Object.defineProperty(t,'value',{
						get:function(){
							return this.translate();
						}
					});
					return t;
				}
			};

			main();

			Object.defineProperty(o,'LOCALE',{
				get:function(){
					return locale;
				}
			});
			return o;
		}];
	}])